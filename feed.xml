<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bolducke.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bolducke.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-03-18T22:35:15+00:00</updated><id>https://bolducke.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">Modern CMake Example</title><link href="https://bolducke.github.io/blog/2023/modern_cmake_example/" rel="alternate" type="text/html" title="Modern CMake Example" /><published>2023-10-21T11:59:00+00:00</published><updated>2023-10-21T11:59:00+00:00</updated><id>https://bolducke.github.io/blog/2023/modern_cmake_example</id><content type="html" xml:base="https://bolducke.github.io/blog/2023/modern_cmake_example/"><![CDATA[<p>Because there is a lack of example online using CMake and targets, I decided to make the following gist public for my futur self.</p>

<p>`<noscript>&lt;pre&gt;400: Invalid request&lt;/pre&gt;</noscript><script src="https://gist.github.com/98575d9a544654b5c659e425e20d3ba4.js"> </script></p>]]></content><author><name></name></author><category term="CMake" /><summary type="html"><![CDATA[An example for my futur self]]></summary></entry><entry><title type="html">System Design Takeaway | ECS-Like (Archetypes)</title><link href="https://bolducke.github.io/blog/2023/design_takeaway_ecsarchetype/" rel="alternate" type="text/html" title="System Design Takeaway | ECS-Like (Archetypes)" /><published>2023-05-28T11:59:00+00:00</published><updated>2023-05-28T11:59:00+00:00</updated><id>https://bolducke.github.io/blog/2023/design_takeaway_ecsarchetype</id><content type="html" xml:base="https://bolducke.github.io/blog/2023/design_takeaway_ecsarchetype/"><![CDATA[<p>For my breakout game, I wanted to explore different system designs and stay away from OOP. I intentionally overcomplicated my project to spot potential “pain point”.</p>

<h1 id="close-set--open-set-mindset">Close Set / Open Set Mindset</h1>

<p>My mindset was to change my perspective from an “open-set” to a “close-set” problem. It’s very hard to successfully create a <em>future-proof</em> project/library. A good <em>real-life</em> example is Vulkan with their API where they recently <em>backed down</em> from their original API (proposed in 2016) because most people, in the game dev. community, were unsatisfied with.</p>

<p>In that regard, by having an “close-set” mentality, I went for the simplest approach that I came up. In small time frame, I was able to build something way more efficiently than before.</p>

<h1 id="ecs-coupling">ECS Coupling</h1>

<p>ECS-like architecture is a great way to make your code more modular while not compromising too much on performance. However, pure ECS can be a little janky when systems are coupled/related (which happen all the time). This is an issue on its own. (There is multiple blog post on the matter on the internet). In practice, it involves dealing with events, callbacks, and dynamic components. Even for entities, it can be a little overwhelming (<a href="https://skypjack.github.io/2019-06-25-ecs-baf-part-4/">See</a>).</p>

<h2 id="systems">Systems</h2>
<p>Instead, I went, again, for a “simpler” approach where each system gathers information through their process, and then, in the main loop, you intertwine those pieces of information “manually”. As a developper, I find it easier to make the systems interact together than to rely on “black-box” framework.</p>

<h2 id="entity">Entity</h2>
<p>I went for a pointer/index-based approach that references each entity internally through a tree-like data structure as mentioned in the blog post of Skypjack.</p>

<h1 id="ecs-archetype">ECS Archetype</h1>

<p>There is no unique way to represent an ECS system. In practice, however, there is two mainstream way. You can separate each likable entity with a common archetype or trait each component individually. In the former case, you have a pool of components for every archetype. In the latter case, your components are all share in a common pool.</p>

<p>Personally, I separated each pool to process them because it is was more common to apply logic based on a specific type that share common components, but behave differently. However, It make it harder to add “custom” information to one entity. It’s hard to say if I made the right call.</p>

<h1 id="breakdown-subtype-polymorphism--archetype-design">Breakdown: Subtype Polymorphism &amp; Archetype Design</h1>

<p>Before this experiment, I always went for OOP without truly thinking about why I was using OOP in the first place. I try something differently. I was always finding myself in this over-abstraction hole and was heavily slowdown. Anyway, this is a very profound and interesting subject and I am just beginning to form an opinion of my own. I present two simple showcase highlighting the main difference between those two approaches.</p>

<h2 id="subtype-polymorphism">Subtype Polymorphism</h2>

<p>Subtype Polymorphism is a tool closely related to OOP where you derived each component member.
Then, to use an entity, you need to cast it for each one.</p>

<pre><code class="language-C">package main

import "core:fmt"

Position :: struct{
    x,y: int,
}

Velocity :: struct {
    dx,dy: int,
}

//Preset
Entity :: struct {
    derived: union{^Ball,^Brick}
}

Ball :: struct {
    using entity: Entity,
    pos: Position,
    vel: Velocity,
}

Brick :: struct {
    using entity: Entity,
    pos: Position,
}

Scene :: struct {
    entities: [dynamic]Entity,
}

init_scene :: proc() -&gt; (s: Scene) {
}

new_entity :: proc(T: typeid) -&gt; Entity {
    t := new(T)
    t.derived = &amp;t
    return t.entity
}

main :: proc() {
    scene := init_scene()

    append(&amp;scene.entities,new_entity(Ball))
    append(&amp;scene.entities,new_entity(Brick))

    for ent in scene.entities {
        switch e in &amp;ent.derived {
            case Ball:
                fmt.println(e.position)
            case Brick:
                fmt.println(e.position)
        }
    }

    for ent in scene.entities {
        #partial switch e in &amp;ent.derived {                
            case Ball:
                fmt.println(e.velocity)
        }
    }

    for ent in scene.entities {
        #partial switch e in &amp;ent.derived {                
            case Ball:
                fmt.println("Ball", e.position,e.velocity)
        }
    }

}

</code></pre>

<h2 id="ecs-like">ECS-Like</h2>

<p>In ECS-like archetype, I keep every entity into different block of memory for each archetype. I can reduce duplication of code between entity that share similar behavior.</p>

<pre><code class="language-C">package main

import "core:fmt"

Position :: struct{
    x,y: int,
}

Velocity :: struct {
    dx,dy: int,
}

//Preset
Ball :: struct {
    pos: Position,
    vel: Velocity,
}

Brick :: struct {
    pos: Position,
}

Archetype :: struct{
    //similar to add a bit_set because union in Odin keep tag
    pos: Maybe([dynamic]Position),
    vel: Maybe([dynamic]Velocity),
}

Scene :: struct {
    archetypes: [2]Archetype,
}

init_scene :: proc() -&gt; (s: Scene) {
    s.archetypes[0].pos = make([dynamic]Position)
    s.archetypes[0].vel = make([dynamic]Velocity)

    s.archetypes[1].pos = make([dynamic]Position)
    s.archetypes[1].vel = nil

    return
}

add_entity_ball :: proc(scene: ^Scene, ball: Ball) {
    append(&amp;scene.archetypes[0].pos.?,ball.pos)
    append(&amp;scene.archetypes[0].vel.?,ball.vel)

}
add_entity_brick :: proc(scene: ^Scene, brick: Brick) {
    append(&amp;scene.archetypes[1].pos.?,brick.pos)
}
add_entity :: proc{add_entity_ball,add_entity_brick}

main :: proc() {
    scene := init_scene()

    add_entity(&amp;scene,Brick{{10,10}})
    add_entity(&amp;scene,Ball{{2,2},{1,1}})

    for a in scene.archetypes {
        if ps, ok := a.pos.?; ok {
            for p in ps {
                fmt.println("Position", p)
            }
        }
    }

    for a in scene.archetypes {
        if vs, ok := a.vel.?; ok {
            for v in vs {
                fmt.println("Velocity", v)
            }
        }
    }

    {
        a := scene.archetypes[0]

        ps := a.pos.?
        vs := a.vel.?

        nb := len(ps)

        for i in 0..&lt;nb {
            fmt.println("Ball", ps[i],vs[i])
        }
    }

    //Alternative
    for a in scene.archetypes {
        ps, okp := a.pos.?
        vs, okv := a.vel.?

        if okp &amp;&amp; okv {
            nb := len(ps)

            for i in 0..&lt;nb {
                fmt.println("p+v", ps[i],vs[i])
            }
        }
    }
}
</code></pre>]]></content><author><name></name></author><category term="Architecture-Design" /><category term="SDL" /><summary type="html"><![CDATA[A small breakdown of my architecture experimentation on my breakout clone]]></summary></entry><entry><title type="html">First Impression of Odin</title><link href="https://bolducke.github.io/blog/2023/odin_first_impression/" rel="alternate" type="text/html" title="First Impression of Odin" /><published>2023-04-10T11:59:00+00:00</published><updated>2023-04-10T11:59:00+00:00</updated><id>https://bolducke.github.io/blog/2023/odin_first_impression</id><content type="html" xml:base="https://bolducke.github.io/blog/2023/odin_first_impression/"><![CDATA[<h1 id="odin">Odin</h1>

<p>Odin is a new language made by Gingerbil. The language is pretty new compared to the other one. I find it truly enjoyable. I considered it a little bit hipster because it doesn’t follow mainstream concepts. This isn’t a bad thing!</p>

<h2 id="interesting-feature-of-odin">Interesting feature of Odin</h2>

<ul>
  <li>Syntax is close to mathematical terminology.</li>
  <li>Use of UTF-8 inside the language.</li>
  <li>Idioms like #optional_ok and #soa enhance greatly the experience.</li>
  <li>Multiple returns supported as a first-class citizen</li>
  <li>Named parameters and returns values!</li>
  <li>Swizzle support for arrays</li>
  <li>Matrix, Quaternion supported as a first-class citizen</li>
  <li><code class="language-plaintext highlighter-rouge">using</code> which gives access to internal values in the current context. This creates a behavior similar to inheritance (in some way).</li>
  <li>Modern Generics</li>
  <li>Lambda function that matches perfectly the procedure syntax declaration</li>
  <li>Explicit overload of function (Could be a downside for some people)</li>
  <li>Ginger</li>
  <li>Type Assertion .? .(Automatic Cast if Type is available)</li>
  <li>Cast and Transmutation</li>
</ul>

<h2 id="external-dependencies">External Dependencies</h2>

<p>This was a concern at first because Odin does not come with a package manager like many modern languages. The main author of the language does not like package managers in general. He considered most of (or all of) them flawed. For this reason, it appears that package manager will never be supported as for Rust, python, etc. However, because of the current build process in Odin, with git-submodule, it is pretty easy to add an external library!</p>

<h2 id="build-and-compilation">Build and Compilation</h2>

<p>Odin is more modern than C and C++ and takes advantage of modern features. The build process is simply a oneliner <code class="language-plaintext highlighter-rouge">odin run .</code> or <code class="language-plaintext highlighter-rouge">odin build .</code> and does not require external software or manual labor to link external dependencies. At the same time, compilation times are fast. The compilation gives interesting feedback when an obvious mistake is done which accelerates the creative process. More could probably be done, but the current team is pretty small and it is already pretty impressive.</p>

<h2 id="debugging">Debugging</h2>

<p>Debugging can be done with <code class="language-plaintext highlighter-rouge">lldb</code>, but it is limited to the terminal. At the moment of writing this text, the debugger is buggy and the feature are limited.</p>

<h2 id="assertion-error-handling">Assertion, Error Handling</h2>

<p>In the current version, Odin does not support exceptions. It doesn’t seem that the author wants to support this feature either. To achieve a similar result, one can use #ok_optional with a bool or an enum to return the current exception.  In fact, as he sees it, he thinks that exceptions were wrong. Those should be handled as early as possible. I was dubious at first, but by experimenting with it and #ok_optional, I saw another way to handle mistakes. A more complex experiment should be done to explore more the limitation of such technic.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As you can see, Odin is very opinionated which has his benefits and issues. In the case of Odin, I would argue that he proposes interesting solutions to common issues in programming. As a very strong point for me, I’m really happy that someone gives enough reflection on the actual syntax/semantics. Most of the choices made feel coherent. It’s very neat that procedure inside a function or outside keeps the same syntax.</p>

<p>I truly recommend one to test it to make their own opinion. As for me, for a really small project, it was a really pleasant adventure</p>]]></content><author><name></name></author><category term="Odin" /><category term="SDL" /><category term="Languages" /><summary type="html"><![CDATA[A small breakdown of an app that I built with Odin and my half-baked opinion on the language]]></summary></entry></feed>